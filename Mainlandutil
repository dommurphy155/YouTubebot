main.py
import asyncio
import atexit
import os
import random
import re
import signal
import time
import utils

# ensure headless to work on VPS / micro VM
os.environ["DISPLAY"] = ":99"

try:
    import psutil  # optional; used for RAM/Firefox leak control
except Exception:
    psutil = None

import telegram
from selenium.webdriver.common.by import By
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.support.ui import WebDriverWait
from telegram import InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (Application, CallbackQueryHandler, MessageHandler,
                          filters)

from config import (OUTPUT_PATH, TELEGRAM_BOT_TOKEN, TELEGRAM_CHAT_ID,
                    TIKTOK_HOMEPAGE, log)
from downloader import download_video, extract_video_metadata
from scraper import (apply_cookies, convert_json_to_netscape,
                     get_fresh_video_link, load_cookies, setup_browser)
from utils import (BROWSER_RESTART_PRELOADS, JANITOR_INTERVAL_SEC,
                   MEM_SOFT_LIMIT_MB, METADATA_BY_PATH, NETSCAPE_COOKIES_FILE,
                   PENDING_POSTS, PLAYED_VIDEOS, PRELOAD_TARGET, VIDEO_CACHE,
                   VIDEO_QUEUE, cleanup_files, current_process_rss_mb,
                   enforce_disk_budget, prune_seen_urls_if_needed,
                   push_played_video)
from poster import post_video_async

log(f"Using python-telegram-bot version: {telegram.__version__}")

BROWSER_DRIVER = None

# ------------------- Browser recycle -------------------
async def _recycle_browser_if_needed():
    global BROWSER_DRIVER, PRELOAD_COUNTER
    try:
        rss_mb = current_process_rss_mb() if psutil else -1
        need_restart = PRELOAD_COUNTER >= BROWSER_RESTART_PRELOADS or (
            rss_mb > 0 and rss_mb >= MEM_SOFT_LIMIT_MB
        )
        if need_restart:
            reason = (
                f"preloads={PRELOAD_COUNTER}"
                if PRELOAD_COUNTER >= BROWSER_RESTART_PRELOADS
                else f"RSS={rss_mb}MB"
            )
            log(f"[INFO] Recycling Firefox due to {reason}")
            _shutdown_driver()
            await asyncio.sleep(0.5)
            BROWSER_DRIVER = setup_browser()
            cookies = load_cookies()
            apply_cookies(BROWSER_DRIVER, cookies, TIKTOK_HOMEPAGE)
            PRELOAD_COUNTER += 1
    except Exception as e:
        log(f"[WARNING] Browser recycle failed: {e}")

# ------------------- Init -------------------
async def init_browser_and_queue(n=PRELOAD_TARGET):
    global BROWSER_DRIVER
    BROWSER_DRIVER = setup_browser()
    cookies = load_cookies()
    apply_cookies(BROWSER_DRIVER, cookies, TIKTOK_HOMEPAGE)
    convert_json_to_netscape(
        os.getenv("TIKTOK_COOKIES_FILE", "tiktok_cookies.json"), NETSCAPE_COOKIES_FILE
    )

    while len(VIDEO_QUEUE) < n:
        video_url = get_fresh_video_link(BROWSER_DRIVER)
        VIDEO_QUEUE.append(video_url)
    log(f"Preloaded {len(VIDEO_QUEUE)} videos.")

# ------------------- Pre-download -------------------
async def pre_download_task():
    global BROWSER_DRIVER
    while True:
        try:
            if len(VIDEO_CACHE) < 1 and VIDEO_QUEUE:
                next_video_url = VIDEO_QUEUE.popleft()
                res = await download_video(next_video_url, OUTPUT_PATH)
                if res:
                    path, _meta = res
                    log(f"Pre-downloaded next video: {path}")
            while len(VIDEO_QUEUE) < PRELOAD_TARGET:
                candidate = get_fresh_video_link(BROWSER_DRIVER)
                VIDEO_QUEUE.append(candidate)
                log("Added new video URL to queue")
            await asyncio.sleep(1.0)
        except Exception as e:
            log(f"[WARNING] pre_download_task failed: {e}")
            await asyncio.sleep(5.0)

# ------------------- Posting helper -------------------
def blocking_post_video(driver, video_path, caption, hashtags):
    try:
        driver.get(TIKTOK_HOMEPAGE)
        wait = WebDriverWait(driver, 15)
        time.sleep(random.uniform(1, 2))
        file_input = wait.until(
            EC.presence_of_element_located((By.CSS_SELECTOR, 'input[type="file"]'))
        )
        file_input.send_keys(video_path)
        time.sleep(random.uniform(2, 4))
        caption_elem = wait.until(
            EC.presence_of_element_located(
                (By.CSS_SELECTOR, '[contenteditable="true"]')
            )
        )
        full_caption = (caption or "") + " " + " ".join(hashtags or [])
        for ch in full_caption:
            caption_elem.send_keys(ch)
            time.sleep(random.uniform(0.02, 0.08))
        time.sleep(random.uniform(1, 3))
        post_button = wait.until(
            EC.element_to_be_clickable((By.XPATH, '//button[contains(text(), "Post")]'))
        )
        post_button.click()
        time.sleep(5)
        log(f"Posted video {video_path} via Selenium.")
        return True
    except Exception as e:
        log(f"[ERROR] blocking_post_video failed: {e}")
        return False

# ------------------- Telegram -------------------
async def send_video(bot, chat_id, video_path, index, caption=None):
    if not os.path.exists(video_path):
        log(f"[ERROR] Video file {video_path} does not exist")
        return None

    metadata = METADATA_BY_PATH.get(video_path)
    if not metadata:
        video_id = os.path.basename(video_path).replace(".mp4", "")
        video_url = f"https://www.tiktok.com/video/{video_id}"
        metadata = await extract_video_metadata(video_url, timeout_sec=8) or {
            "caption": "",
            "hashtags": [],
        }
        METADATA_BY_PATH[video_path] = metadata

    caption_text_parts = [caption] if caption else []
    if metadata.get("caption"):
        caption_text_parts.append(f"Original Caption: {metadata.get('caption')}")
    if metadata.get("hashtags"):
        caption_text_parts.append(f"Hashtags: {' '.join(metadata.get('hashtags'))}")
    caption_text = "\n\n".join(caption_text_parts) if caption_text_parts else None

    buttons_row = []
    if index > 0:
        buttons_row.append(
            InlineKeyboardButton("◀️ Previous", callback_data="prev_video")
        )
    buttons_row.append(InlineKeyboardButton("Post ⬆️", callback_data="post_video"))
    buttons_row.append(InlineKeyboardButton("Next ▶️", callback_data="next_video"))
    markup = InlineKeyboardMarkup([buttons_row])

    for attempt in range(3):
        try:
            with open(video_path, "rb") as f:
                msg = await bot.send_video(
                    chat_id=chat_id, video=f, reply_markup=markup, caption=caption_text
                )
            log(f"Sent video {video_path}")
            return msg.message_id
        except Exception as e:
            log(f"[ERROR] Attempt {attempt+1} failed to send video {video_path}: {e}")
            await asyncio.sleep(1)
    return None

# ------------------- Navigation -------------------
async def _handle_next_action(bot, chat_id=None):
    from utils import CURRENT_INDEX

    if VIDEO_CACHE:
        next_path = VIDEO_CACHE.popleft()
        if next_path not in PLAYED_VIDEOS:
            push_played_video(next_path, update_index=True)
            log(f"Moved ready video to played: {next_path}")

    target_chat = chat_id or TELEGRAM_CHAT_ID
    if 0 <= CURRENT_INDEX < len(PLAYED_VIDEOS):
        await send_video(bot, target_chat, PLAYED_VIDEOS[CURRENT_INDEX], CURRENT_INDEX)

async def navigation_callback(update, context):
    from utils import CURRENT_INDEX

    query = update.callback_query
    await query.answer()
    chat_id = query.message.chat_id
    try:
        await query.message.delete()
    except Exception:
        pass

    if query.data == "next_video":
        await _handle_next_action(context.bot, chat_id)
    elif query.data == "prev_video":
        if CURRENT_INDEX > 0:
            CURRENT_INDEX -= 1
            await send_video(context.bot, chat_id, PLAYED_VIDEOS[CURRENT_INDEX], CURRENT_INDEX)
    elif query.data == "post_video":
        if 0 <= CURRENT_INDEX < len(PLAYED_VIDEOS):
            video_path = PLAYED_VIDEOS[CURRENT_INDEX]
            PENDING_POSTS[chat_id] = {
                "stage": 1,
                "video_path": video_path,
                "comment": None,
                "hashtags": None,
                "prompt_msg_ids": [],
            }
            msg = await context.bot.send_message(
                chat_id=chat_id, text="What would you like to comment?"
            )
            PENDING_POSTS[chat_id]["prompt_msg_ids"].append(msg.message_id)

async def text_message_handler(update, context):
    chat_id = update.effective_chat.id
    if chat_id not in PENDING_POSTS:
        return

    flow = PENDING_POSTS[chat_id]
    stage = flow.get("stage", 1)

    # === Stage 1: Collect comment ===
    if stage == 1:
        flow["comment"] = update.message.text or ""

        # Delete previous prompts
        for mid in flow.get("prompt_msg_ids", []):
            try:
                await context.bot.delete_message(chat_id=chat_id, message_id=mid)
            except Exception:
                pass
        flow["prompt_msg_ids"] = []

        # Ask for hashtags
        msg = await context.bot.send_message(
            chat_id=chat_id,
            text="What would you like as your hashtags?"
        )
        flow["prompt_msg_ids"].append(msg.message_id)
        flow["stage"] = 2

    # === Stage 2: Collect hashtags and post ===
    elif stage == 2:
        flow["hashtags"] = update.message.text or ""

        # Delete previous prompts
        for mid in flow.get("prompt_msg_ids", []):
            try:
                await context.bot.delete_message(chat_id=chat_id, message_id=mid)
            except Exception:
                pass
        flow["prompt_msg_ids"] = []
        flow["stage"] = 3  # posting

        async def do_post():
            try:
                hashtags_list = [t for t in re.split(r"\s+", flow.get("hashtags") or "") if t]
                await post_video_async(
                    bot=context.bot,
                    chat_id=chat_id,
                    video_path=flow.get("video_path"),
                    comment=flow.get("comment"),
                    hashtags=hashtags_list
                )
            except Exception as e:
                log(f"[ERROR] text_message_handler do_post exception: {e}")
                await context.bot.send_message(
                    chat_id=chat_id,
                    text=f"❌ Error posting TikTok: {e}"
                )
            finally:
                # Cleanup pending flow
                if chat_id in PENDING_POSTS:
                    del PENDING_POSTS[chat_id]

        asyncio.create_task(do_post())

# ------------------- Janitor -------------------
async def janitor_task():
    while True:
        try:
            cleanup_files()
            enforce_disk_budget()
            prune_seen_urls_if_needed()
            await _recycle_browser_if_needed()
        except Exception as e:
            log(f"[WARNING] janitor_task failed: {e}")
        await asyncio.sleep(JANITOR_INTERVAL_SEC)

# ------------------- Graceful shutdown -------------------
def _shutdown_driver():
    global BROWSER_DRIVER
    try:
        if BROWSER_DRIVER:
            BROWSER_DRIVER.quit()
            BROWSER_DRIVER = None
            log("Firefox WebDriver closed")
    except Exception as e:
        log(f"[WARNING] Failed to close WebDriver: {e}")

def _handle_exit(*_args):
    cleanup_files()
    _shutdown_driver()

atexit.register(_handle_exit)
signal.signal(signal.SIGINT, _handle_exit)
signal.signal(signal.SIGTERM, _handle_exit)

# ------------------- Main -------------------
async def post_init(application):
    global CURRENT_INDEX, BROWSER_DRIVER
    log("Starting TikTok downloader with Telegram bot...")
    await init_browser_and_queue(PRELOAD_TARGET)

    if VIDEO_QUEUE:
        first_url = VIDEO_QUEUE.popleft()
        res1 = await download_video(first_url, OUTPUT_PATH)
        if res1:
            first_path, _ = res1
            push_played_video(first_path, update_index=True)
            CURRENT_INDEX = 0

    asyncio.create_task(pre_download_task())
    asyncio.create_task(janitor_task())

    if 0 <= CURRENT_INDEX < len(PLAYED_VIDEOS):
        await send_video(
            application.bot,
            TELEGRAM_CHAT_ID,
            PLAYED_VIDEOS[CURRENT_INDEX],
            CURRENT_INDEX,
        )

if __name__ == "__main__":
    app = Application.builder().token(TELEGRAM_BOT_TOKEN).post_init(post_init).build()
    app.add_handler(
        CallbackQueryHandler(
            navigation_callback, pattern="^(next_video|prev_video|post_video)$"
        )
    )
    app.add_handler(
        MessageHandler(filters.TEXT & (~filters.COMMAND), text_message_handler)
    )
    asyncio.run(app.run_polling())
    _handle_exit()

This is utils.py:
import os
import shutil
from collections import deque

try:
    import psutil
except Exception:
    psutil = None

from config import OUTPUT_PATH, log

# ------------------- Tunables -------------------
NETSCAPE_COOKIES_FILE = "tiktok_cookies.txt"
PRELOAD_TARGET = 3
VIDEO_QUEUE = deque(maxlen=PRELOAD_TARGET)
VIDEO_CACHE = deque(maxlen=3)
HISTORY_MAX = 3
SEEN_URLS_MAX = 250
SCROLL_SLEEP_RANGE = (1.0, 1.6)
OUTPUT_DISK_QUOTA_MB = int(os.getenv("OUTPUT_DISK_QUOTA_MB", "1024"))
OUTPUT_DISK_RESERVE_MB = int(os.getenv("OUTPUT_DISK_RESERVE_MB", "2048"))
JANITOR_INTERVAL_SEC = 180
BROWSER_RESTART_PRELOADS = 200
MEM_SOFT_LIMIT_MB = int(os.getenv("MEM_SOFT_LIMIT_MB", "1200"))

# ------------------- Globals -------------------
PRELOADED_VIDEOS = set()
SEEN_URLS = deque()
PLAYED_VIDEOS = []
CURRENT_INDEX = -1
PRELOAD_COUNTER = 0
METADATA_BY_PATH = {}
PENDING_POSTS = {}


# ------------------- Utils -------------------
def safe_delete(path: str):
    try:
        if path and os.path.exists(path):
            os.remove(path)
            log(f"Deleted file: {path}")
    except Exception as e:
        log(f"[WARNING] Failed to delete {path}: {e}")


def _keep_set():
    return set(PLAYED_VIDEOS) | set(VIDEO_CACHE)


def cleanup_files():
    try:
        keep = _keep_set()
        if not os.path.isdir(OUTPUT_PATH):
            return
        for name in os.listdir(OUTPUT_PATH):
            if name.lower().endswith(".mp4"):
                candidate = os.path.join(OUTPUT_PATH, name)
                if candidate not in keep:
                    safe_delete(candidate)
    except Exception as e:
        log(f"[WARNING] cleanup_files failed: {e}")


def prune_seen_urls_if_needed():
    while len(SEEN_URLS) > SEEN_URLS_MAX:
        oldest = SEEN_URLS.popleft()
        PRELOADED_VIDEOS.discard(oldest)


def add_seen_url(href: str):
    if href in PRELOADED_VIDEOS:
        return
    if len(SEEN_URLS) >= SEEN_URLS_MAX:
        oldest = SEEN_URLS.popleft()
        PRELOADED_VIDEOS.discard(oldest)
    PRELOADED_VIDEOS.add(href)
    SEEN_URLS.append(href)


def push_played_video(path: str, update_index=True):
    global CURRENT_INDEX, VIDEO_CACHE, PLAYED_VIDEOS
    if path not in PLAYED_VIDEOS:
        PLAYED_VIDEOS.append(path)
    if path in VIDEO_CACHE:
        VIDEO_CACHE.remove(path)
    if len(PLAYED_VIDEOS) > HISTORY_MAX:
        evicted = PLAYED_VIDEOS.pop(0)
        if evicted in VIDEO_CACHE:
            VIDEO_CACHE.remove(evicted)
        if CURRENT_INDEX > 0:
            CURRENT_INDEX -= 1
    if update_index:
        CURRENT_INDEX = len(PLAYED_VIDEOS) - 1
    cleanup_files()


def folder_size_bytes(folder: str) -> int:
    total = 0
    try:
        for entry in os.scandir(folder):
            if entry.is_file(follow_symlinks=False):
                total += entry.stat().st_size
    except Exception:
        pass
    return total


def enforce_disk_budget():
    try:
        if not os.path.isdir(OUTPUT_PATH):
            return
        cleanup_files()
        quota_bytes = OUTPUT_DISK_QUOTA_MB * 1024 * 1024
        reserve_bytes = OUTPUT_DISK_RESERVE_MB * 1024 * 1024
        folder_bytes = folder_size_bytes(OUTPUT_PATH)

        def constraints_ok() -> bool:
            u = shutil.disk_usage(OUTPUT_PATH)
            return (folder_bytes <= quota_bytes) and (u.free >= reserve_bytes)

        safety_counter = 0
        while not constraints_ok():
            safety_counter += 1
            if safety_counter > 100:
                log("[WARNING] Disk janitor safety stop hit.")
                break
            if PLAYED_VIDEOS:
                current_path = (
                    PLAYED_VIDEOS[CURRENT_INDEX]
                    if 0 <= CURRENT_INDEX < len(PLAYED_VIDEOS)
                    else None
                )
                did_delete = False
                while PLAYED_VIDEOS:
                    oldest = PLAYED_VIDEOS[0]
                    if oldest == current_path and len(PLAYED_VIDEOS) == 1:
                        break
                    if oldest == current_path:
                        if len(PLAYED_VIDEOS) >= 2:
                            second = PLAYED_VIDEOS[1]
                            PLAYED_VIDEOS.pop(1)
                            safe_delete(second)
                            did_delete = True
                            break
                        else:
                            break
                    else:
                        PLAYED_VIDEOS.pop(0)
                        safe_delete(oldest)
                        did_delete = True
                        break
                if did_delete:
                    continue
            if VIDEO_CACHE:
                old_file = VIDEO_CACHE.popleft()
                if old_file not in set(PLAYED_VIDEOS):
                    safe_delete(old_file)
                continue
            keep = _keep_set()
            candidates = [
                os.path.join(OUTPUT_PATH, n)
                for n in os.listdir(OUTPUT_PATH)
                if n.lower().endswith(".mp4")
                and os.path.join(OUTPUT_PATH, n) not in keep
            ]
            if candidates:
                candidates.sort(key=lambda p: os.stat(p).st_mtime)
                safe_delete(candidates[0])
            else:
                break
    except Exception as e:
        log(f"[WARNING] enforce_disk_budget failed: {e}")


def current_process_rss_mb() -> int:
    if not psutil:
        return -1
    try:
        p = psutil.Process(os.getpid())
        return int(p.memory_info().rss / (1024 * 1024))
    except Exception:
        return -1
(myenv) ubuntu@wtf:~$  make sure you keep get fresh video link the exact same don’t change anything it must still run exactly how it does just find the videos as it already does not not change anything other than the little things honestly don’t help where is it needed it need to operate the exact same MAKE SURE ALL LIMES ARE STILL THERE IN EACH FILE DONT REMOVE OR ADD ANY LINES AT ALL JUST FIX THE EXISTING LINES TO MAKE THEM WORK 
